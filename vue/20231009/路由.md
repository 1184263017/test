# 路由

## 什么是路由

借鉴了后端的路由概念
- 后端: 配一个资源路径(字符串),符合就执行回调函数返回响应信息
- 前端: 配一个路径(字符串),符合就显示一个组件

## hash

1. url # 后的字符就是hash字符串
2. hash 字符的变化不会导致页面重新刷新
3. `window.onhashchange` 事件可以监听到hash的变化
4. `window.location.hash` 获取当前hash值
```js
  mounted() {
    // 监听事件
    window.onhashchange = () => {
      // 获取hash值
      this.path = window.location.hash.slice(1);
    };
  },
```

## 路由表

1. 路径映射真实组件
2. 获取hash,比对路由表获取组件

## Vue Router

### 下载

`npm install vue-router@3`

### 使用

`import VueRouter from 'vue-router'`
- VueRouter 可以当中构造函数使用,构造路由(表)

### Vue.use(VueRouter)  作用

1. 生成对象 router (new VueRouter), 混入到每一个vue (this.$router)组件对象中-**相当于路由表**
2. 生成对象 route , 混入到每一个vue (this.$route)组件对象中 -**相当于`window.location`**, location 把地址url对象化,route 把地址url中的hash部分对象化
3. 注册全局组件 `<router-link></router-link>` -**相当于`<a></a>`**
4. 注册全局组件 `<router-view></router-view>` -**相当于`<component></component>`**

> 如果混入对象需要动态设定,那么可以使用root选项+全局混入的方式,其他情况直接混入就可以

### 动态路由匹配

1. 所有路径部分,都可以在路径前面加一个 `:` ,变成动态路径参数(动态路由参数)
2. 变成动态路径参数(动态路由参数)可以有多个,路由参数按照先后顺序和url进行位置匹配
3. 可以通过 `$route.params` 对象获取动态路径参数值

### 路由传参

1. 路径传参(参与路由匹配),可以通过 `$route.params` 对象获取参数值
2. 查询字符串传参(不参与路由匹配),可以通过 `$route.query` 对象获取参数值
3. 哈希传参(不参与路由匹配),可以通过 `$route.hash` 对象获取参数值

### 路由参数实现组件传参

1. A组件设定到目标B组件的路由导航
2. 在A中通过路径,查询字符串,hash绑定A中的数据
3. 触发A-B导航,实现数据在任意组件间的传递

### watch 检测地址栏变化

底层原理就是`window.onhashchange` 事件监听hash的变化
```js
watch: {
    $route: {
      handler(newV, oldV) {
        console.log(newV, oldV);
      },
      immediate: true,
      deep:false,
    },
  },
```

## 路由匹配优先级 Not Fund

1. 路由是按照路由表的先后顺序匹配
2. 从第一个路由到最后一个路由,优先级从高到底
3. 如果匹配成功,就终止匹配(即使后面有符合的匹配项)
4. 如果所有路由都匹配不上,`router-view` 置空不显示
5. 可以使用 `*` 路径通配所有的路由,实现 Not Fund 此路由只能写在最后

## 嵌套路由

### 数据解构

```js
const router = new VueRouter({
  routes: [{
      path: '/user/a',
      component: UserA,
      children: [{
        path: '',
        component: UserA,
        children:[{}]
      }]
    },
  ],
});
```

### 嵌套路由配置项

1. path 符合路径格式,要求不要用/开始
2. 访问嵌套路由的路径写法,将嵌套结构的所有path属性由高到底(父到子)拼接到一起就可以

嵌套路由的组件显示

1. 第一层路由全部显示在 `App-><router-view></router-view>` 中
2. 嵌套路由组件显示在 `父路由-><router-view></router-view>` 或者 `上级路由-><router-view></router-view>`

## 编程式导航

将导航的路径由字符串该为对象

1. path   导航路径
2. name   命名路由对象,必须唯一
2. query  将查询参数以对象的方式传入,可以避免语法错误,更容易绑定变量,方便编辑
3. hash   设置hash值
5. params 使用name导航,需要传递路径参数的时候才会使用

router.push 方法

1. `this.$router.push('/user/b/200')` 等价 `to='路径字符串'`
2. `this.$router.push({path: "/user/b/200",query: { name: "jack", age: 20 },hash: "www",})` 等价 `to='路由对象'`

解决 NavigationDuplicated 异常

1. 如果在A导航中,导航(push)A,就会发生这样的错误
2. 如果想避抛错可以使用错误捕捉,因为push返回值是一个promise,所以可以使用catch捕捉错误(捕捉不处理),一般不写then,也可以使用awit+try...catch的方式进行捕捉

router.replace 和 push 的区别

1. 参数传递和push一样
2. 区别在于push会在浏览器中留下历史记录,但replace不会,只有一条记录,表示当前页面地址

router.go(n) 跳转历史记录,基于用户浏览历史导航

- go(1)   向前跳转1次
- go(2)   向前跳转2次
- go(0)   刷新
- go(-1)  向后跳转1次
- go(-2)  向后跳转2次

原生

- window.history.go()
- window.history.back()    等同于 go(-1)
- window.history.forward() 等同于 go(1)
- window.history.reload()  等同于 go(0)
- window.history.pushState()
- window.history.replaceState()


## 命名路由

1. 所有的路由对象都可以配置一个name属性,唯一指代当前路由对象
2. name属性在整个路由对象中不能重复
3. 可用于做编程式导航,必须配合对象使用

## 命名视图

1. 给router view 命名
2. 路由配置加载组件时候,必须要指定视图名称
3. `name="default"` 表示默认视图 可以省略不写

## 嵌套命名视图

1. 嵌套路由中的组件可以展示在上级路由视同中的
2. 必须保证所有的上级路由组件中都有视图 `router-view`
3. 如果上一级是多视图的话,那么会在每一个视同中找对应的`name`显示子路由中的组件


### 路由组件传参

1. 设置一个和路径参数同名的组件属性参数
2. 设置路由选项 `props = true`
3. 路径参数的值会直接传递给路由组件的同名属性参数也就是组件的props接受参数
4. 如果是多组件视图的换必须每个视图单独设置props `props:{default:true,a:true,b:true}`

## HTML5 History模式

用户修改浏览器地址栏的样子

1. hash
2. history

区别
1. 配置方式: `mode:'hash'` 和 `mode:'history'`
2. 页面刷新: 直接修改地址 history 模式会刷新页面 hash 不会刷新
3. 是否需要服务器支持:history需要后端重写url路径,hash纯浏览器技术不需要
4. 兼容性:hash兼容性最好,history由于底层用到了一个比较新的api过低版本的浏览器是不支持

## 路由进阶

1. beforeEach 全局前置
2. afterEach  全局后置

next 参数

1. next(false) 直接拦截
2. next(new Error) 拦截并抛错
3. next(路径/路由对象) 拦截并跳转

组件内离开守卫

- 是第一个触发的守卫(enter),如果是update情况,第一个发生的是全局前置
- 拦截的是离开,next(false)阻止离开

beforeRouteEnter
- 一般我们在组件内路由守卫可以获取组件对象(this)
- beforeRouteEnter发生时间早于beforeCreated 所以无法通过this获取组件对象
- 可以通过守卫next回调函数获取this,回调函数的执行时间晚于全局后置
```js
  beforeRouteEnter(to, from, next) {
    // console.log(this); // 无法获取this
    console.log("beforeRouteEnter", "c");
    next(vm=>console.log(vm));
  },
```


 触发顺序
- 页面跳转时触发
- beforeRouteLeave > beforeEach > beforeEnter > beforeRouteEnter > beforeResolve > afterEach(没有next参数)
- 组件离开守卫 > 全局前置 > 路由独享 > 组件内Enter > 全局解析守卫 > 全局后置

- 只在当前页面修改跳转时触发
- beforeEach > beforeRouteUpdate > beforeResolve > afterEach(没有next参数)
- 全局前置 > 组件内Update > 全局解析守卫 > 全局后置



## 动态菜单

根据路由对象生成导航菜单

1. 获取所有的路由对象
```js
// 获取所有路由
this.$router.options.routes 
```
2. 通过v-for实现路由对象->菜单导航动态显示
3. 可以将菜单的显示数据全部定义到meta中

meta 应用场景

1. 设置导航菜单信息(菜单名,菜单图标)
2. 配合路由拦截设置访问权限(登录访问,权限访问)


### 路由懒加载

1. 写法
```js
  {
      name: 'login',
      path: '/login',
      component: () => import(/* webpackChunkName: "group-foo" */ './components/Login.vue'),
      meta: {
        // 元数据
        name: '登录页',
        hidden: true,
        logined: false,
      }
    },  
```
2. 优化首屏加载速度,只有路由被访问的时候才会加载


### 把组件按组分块

1. `/* webpackChunkName: "group-foo" */`将路由组件分为多个js文件打包
2. 小文件可以提高网络的加载速度,减少加载时间
3. 必须要配合路由懒加载使用,同时去掉同步导入路径


## 多级菜单创建

### 文件命名

1. 所有的vue组件必须要归类到文件夹中
2. 文件夹小写命名,vue文件多单词大驼峰命名

### 公共部分

1. 可以将所有页面的公共部分采放到 layout 组件中
2. 项目的一级路由统一加载 layout,实现了公共部分的抽离
3. 公共页面交互写入 layout 中,独立个性化的页面交互分别写到各自的子路由组件中

### 导航菜单

1. 必须要写入公共组件 layout
2. 基于routers对象生成ul列表菜单
3. 基于一级路由遍历生成第一级ul列表菜单,继续遍历一级路由children,嵌套ul生成二级路由,其他层级依此类推
4. 点击一级路由链接,默认显示(跳转)任意一个子路由
- 可以通过配置路由重定向redirect实现
```js
{
    name: 'Home',
    path: '/home',
    component: LayoutIndex,
    redirect: {
        name: 'HomeIndex'
    },
    meta: {
        name: '首页'
    },
    children: [{
        path: 'index',
        name: 'HomeIndex',
        component: HomeIndex,
        meta: {
            name: '首页详情'
        }
    }, ]
}
```
- 可以通过路由遍历中直接设置 `name为children[0].name` 来实现
5. 如果只有一个子路由,只显示上级路由,可以通过判断子路由的个数是否小于等于1来实现

面包屑导航

1. route.matched 数组保存了路由的嵌套路径
2. 遍历 matched 数组生成面包屑导航,间隔符可以使用css样式来实现



## 模块化

1. 创建文件 `src/router/index.js`
2. 将所有路由相关代码移入文件 `index.js` 
3. `index.js`  导出变量 `router`
4. 路径可以使用 `@` 别名,`@==src`