# vue

## 创建项目

### vue create(webpack安装)
```shell
vue create 项目名称
```

1. 手动安装 Manually select features
2. 选中需要安装的组件, Babel,CSS Pre-processors
3. 选中版本 3.x
4. 选中css预处理器 scss
5. 选中配置文件保留位置,单独保存  In dedicated config files

### npm init
```shell
npm init vaue@latest
```
1. Need to install the following packages Y
2. 输入项目名称
3. 是否使用TypeScript语法? 否
4. 是否启用 JSX 支持？ 否
5. 是否引入 Vue Router 进行单页面应用开发？ 否
6. 是否引入 Pinia 用于状态管理？ 否
7. 是否引入 Vitest 用于单元测试？ 否
8. 是否要引入一款端到端（End to End）测试工具？ 否
9. 是否引入 ESLint 用于代码质量检测？ 否
10. 进入项目根目录 npm install 安装下插件

## 项目构建工具
1. webpack
2. vite

**webpack 区别 vite**
1. 默认启动命令不一样,webpack npm run serve(vue-cli-service serve),vite npm run dev(vite)
2. 启动速度不一样:vite快,webpack慢
3. webpack 需要使用babel编译一次js
4. vite 直接加载js文件不做编译,直接使用原生esmodule


## 创建一个和Vue应用

1. 功能函数化
2. 一个功能一个函数
3. 所有的函数都是独立
4. 在哪里使用就在哪里导入

> vue 提供了很多 API,使用API组合,实现功能,称为组合式API(hook钩子)

1. 导入vue
```js
import { createApp} from 'vue';
```

### createApp 生成一个vue实例
```js
const app = createApp({
    // 配置选项,根配置
})
```

### 挂载
```js
app.mount('#app')
```

### render 选项
```js
import { createApp, h } from 'vue';
render: () => h(App)
```

### createApp
直接渲染单文件组件
```js
const app = createApp(App)
```

### vue3单文件组件

1. 支持vue2选项配置(相同)
2. template不要求唯一根标签(不同)
3. 增加了setup选项
**vue2**
```js
export default {
  name: "App",
  data() {
    return {};
  },
  mounted() { },
  methods: {
    say() {
      console.log('hahahah')
    }
  },
};
```
**vue3**
```js
setup() {
    const title = 'hello';
    function say(params) {
      console.log('hello jack');
    };
    return {
      title,
      say,
    }
  }
```
4. `<script setup></script>` 语法糖写法,让vue3的语法回到原生的写法,选项式写法彻底消失
```js
<script setup>
console.log(username);
const title = 'hello';
function say(params) {
  console.log('hello jack');
};
</script>
```

## 数据和方法

### 数据定义

- 响应式数据
- 非响应式数据

#### 响应式数据

1. ref(10) 返回的是一个对象,此对象被proxy代理,proxy可以监测数据的变化
2. 对象中一个value属性,通过这个属性可以获取响应数据的值
3. 在模版中value属性可以省略不写
4. ref可以实现数据的深层响应

#### shallowRef 函数定义

1. 和ref的区别是,他取消了深层响应
2. 只能通过对整个value属性进行修改,才能触发响应

#### reactive() 响应式变量

1. 主要用于将一个对象定义为响应式
2. 属性值在任何地方都可以直接访问或修改,不需要使用value


#### shallowReactive

1. 和 reactive 的区别是,他取消了深层响应
2. 只能对第一次属性进行响应式修改


#### toref

1. 创建一个变量,这个变量是一个响应式变量,并且和一个响应式对象中的属性保存同步
2. toref就是将reactive对象中的属性转换成ref并保存同步

#### torefs

1. 批量的将一个reactive对象转换成一个普通对象
2. 这个普通对象性中的属性和reactive对象一一对应,值是ref对象，和reactive对象值保存同步


## 计算属性和侦听器

### computed

1. 只读定义 `computed(()=>{})`
2. 读写定义`computed({get(){},set(value){}})`

### watch

1. 单个响应数据侦听 `watch(数据变量,(newValue,oldValue)=>{})`
2. 多个响应数据侦听 `watch([数据变量,数据变量],(newValue,oldValue)=>{})` newValue和oldValue返回的也是数组
3. 侦听对象 `watch(对象,()=>{})`,是深层侦听,对象任何属性发生变化都会执行回调函数
4. 侦听对象某个属性,`watch(()=>对象.属性,()=>{})`,只有属性值发生变化的时候,回调函数才会执行,不是深层侦听
5. 侦听对象的第一层属性 `watch(()=>({...对象}),()=>{})`
6. 第三个参数`{deep: true, immediatetrue: true}` deep:深层监听,immediate:回调函数立即执行一次,此时久值时undefined


## 生命周期钩子

1. onMounted    挂载后执行,可以操作DOM
2. onUpdated    数据页面更新执行
3. onUnmounted  组件销毁执行,比如清除定时器


## 组件基础

defineProps

- 参数可以是`[属性名,...]`
- 参数也可以是`{属性:{配置项}}`
- 返回一个包含所有属性名的对象



